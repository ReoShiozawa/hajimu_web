<p align="center">
  <img src="https://img.shields.io/badge/バージョン-5.4.0-blue" alt="version">
  <img src="https://img.shields.io/badge/言語-C11-orange" alt="lang">
  <img src="https://img.shields.io/badge/ライセンス-MIT-green" alt="license">
  <img src="https://img.shields.io/badge/対応-macOS%20%7C%20Linux%20%7C%20Windows-lightgrey" alt="platform">
</p>

# hajimu_web

**日本語で書ける HTTP サーバー** — [はじむ言語](https://github.com/ReoShiozawa/hajimu)の Web フレームワーク

Python の **Flask**、Node.js の **Express** に相当するプラグインです。
たった 5 行で Web サーバーが動きます。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(8080)
ウェブ.GET("/", "<h1>こんにちは、はじむ！</h1>")
ウェブ.起動()
```

```bash
$ nihongo hello.jp
# → http://localhost:8080/ にアクセス
```

---

## なぜ hajimu_web？

| | **hajimu_web** | Express (Node.js) | Flask (Python) |
|---|---|---|---|
| Hello World | **5 行** | 5 行 | 7 行 |
| 言語 | 日本語 | 英語 | 英語 |
| 依存パッケージ | **0** | npm 依存ツリー | pip 依存 |
| 実装 | **C11 ネイティブ** | JavaScript | Python |
| インストール | `make install` | `npm init && npm i` | `pip install` |
| ミドルウェア | 組み込み 8 種 | 別途インストール | 別途インストール |
| セッション | 組み込み | 要 express-session | 要 Flask-Session |

---

## 目次

- [クイックスタート](#-クイックスタート)
- [インストール](#-インストール)
- [チュートリアル](#-チュートリアル)
  - [Step 1: Hello World](#step-1-hello-world)
  - [Step 2: JSON API を作る](#step-2-json-api-を作る)
  - [Step 3: 動的ルーティング](#step-3-動的ルーティング)
  - [Step 4: ミドルウェアで機能追加](#step-4-ミドルウェアで機能追加)
  - [Step 5: セッション管理](#step-5-セッション管理)
  - [Step 6: テンプレートで動的ページ](#step-6-テンプレートで動的ページ)
  - [Step 7: 実践的な REST API](#step-7-実践的な-rest-api)
- [Express との対応表](#-express-との対応表)
- [機能一覧](#-機能一覧)
- [API リファレンス](#-api-リファレンス)
- [レシピ集](#-レシピ集)
- [アーキテクチャ](#-アーキテクチャ)
- [ビルド](#-ビルド)
- [FAQ](#-faq)
- [変更履歴](#-変更履歴)
- [関連リンク](#-関連リンク)

---

## 🚀 クイックスタート

```bash
# 1. リポジトリをクローン
git clone https://github.com/ReoShiozawa/hajimu-web.git
cd hajimu-web

# 2. ビルド & インストール
make && make install

# 3. サンプルを実行
nihongo examples/hello_server.jp

# 4. ブラウザで開く → http://localhost:8080/
```

---

## 📦 インストール

### ソースからビルド（推奨）

```bash
git clone https://github.com/ReoShiozawa/hajimu-web.git
cd hajimu-web
make
make install    # → ~/.hajimu/plugins/hajimu_web/ にインストール
```

### 手動配置

`hajimu_web.hjp` と `hajimu.json` を以下のいずれかにコピー:

```
~/.hajimu/plugins/hajimu_web/        ← グローバル（推奨）
プロジェクト/hajimu_packages/hajimu_web/  ← プロジェクトローカル
```

> **必要環境:** はじむ言語、C コンパイラ (gcc / clang)、zlib、pthread

---

## 📖 チュートリアル

はじむ言語を使ったことがなくても大丈夫。ステップバイステップで Web サーバーの作り方を学びましょう。

### Step 1: Hello World

最小のサーバーを作ってみましょう。

```
取り込む "hajimu_web" として ウェブ     // ← プラグインを読み込む

ウェブ.サーバー作成(8080)               // ← ポート 8080 でサーバーを初期化
ウェブ.GET("/", "<h1>Hello!</h1>")     // ← "/" にアクセスしたときの応答を設定
ウェブ.起動()                           // ← サーバーを起動（ここでブロック）
```

```bash
nihongo hello.jp
# →  http://localhost:8080/  にブラウザでアクセス
```

**ポイント:**
- `取り込む` で外部パッケージをインポート
- `GET(パス, 応答)` でルートを登録。応答には HTML 文字列が使えます
- `起動()` を呼ぶまではルートの登録だけで、サーバーは動きません

### Step 2: JSON API を作る

フロントエンドや他のサービスから使える API を作ります。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)
ウェブ.CORS有効()                       // ← フロントエンドからのアクセスを許可

// JSON を返す API エンドポイント
ウェブ.JSON応答("/api/status", 200, "{\"状態\": \"正常\"}")
ウェブ.JSON応答("/api/users", 200, "[{\"名前\": \"太郎\"}, {\"名前\": \"花子\"}]")

ウェブ.起動()
```

```bash
$ curl http://localhost:3000/api/status
{"状態": "正常"}

$ curl http://localhost:3000/api/users
[{"名前": "太郎"}, {"名前": "花子"}]
```

### Step 3: 動的ルーティング

**コールバック関数** を使うと、リクエストの内容に応じて動的にレスポンスを返せます。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(8080)

// 関数をハンドラとして登録（Express の app.get() と同じ）
関数 トップページ(リクエスト):
    返す "<h1>ようこそ！</h1><p>はじむウェブへ</p>"
終わり

ウェブ.GET("/", トップページ)

// パスパラメータを使う（:名前 で定義）
関数 ユーザーページ(リクエスト):
    変数 params = リクエスト[6]           // パスパラメータ辞書
    変数 id = params["id"]
    ウェブ.JSON送信({"user_id": id, "name": "太郎"})
終わり

ウェブ.GET("/users/:id", ユーザーページ)  // /users/42 → id = "42"

ウェブ.起動()
```

```bash
$ curl http://localhost:8080/users/42
{"user_id":"42","name":"太郎"}
```

**リクエストオブジェクト** は配列で、よく使うフィールド:

| インデックス | 内容 | 例 |
|---|---|---|
| `リクエスト[0]` | HTTP メソッド | `"GET"` |
| `リクエスト[1]` | パス | `"/users/42"` |
| `リクエスト[2]` | ボディ | `"{\"名前\":\"太郎\"}"` |
| `リクエスト[5]` | ヘッダー辞書 | `headers["Host"]` |
| `リクエスト[6]` | パスパラメータ | `params["id"]` |
| `リクエスト[7]` | クエリパラメータ | `query["page"]` |
| `リクエスト[10]` | Cookie 辞書 | `cookies["session"]` |

**コールバックの返り値** でレスポンスが決まります:

| 返り値 | 動作 |
|---|---|
| 文字列 | そのまま HTML として返す |
| 数値 | その番号のステータスコードで返す（例: `404`） |
| 配列 `[status, content_type, body]` | 自由にカスタマイズ |
| なし（`JSON送信()` 等を使う場合） | 関数内で直接レスポンス |

### Step 4: ミドルウェアで機能追加

**ミドルウェア** はリクエスト処理の前後に自動実行される機能です。
1 行で追加できます。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)

// --- 組み込みミドルウェアを有効化 ---
ウェブ.ミドルウェア("logger")       // ← アクセスログを表示
ウェブ.ミドルウェア("security")     // ← セキュリティヘッダー自動付与
ウェブ.ミドルウェア("compression")  // ← gzip 圧縮を有効化
ウェブ.ミドルウェア("json")         // ← JSON ボディを自動解析
ウェブ.CORS有効()                   // ← CORS ヘッダーを付与

// --- 自作ミドルウェアも作れる ---
関数 認証チェック(リクエスト):
    変数 headers = リクエスト[5]
    もし headers["Authorization"] == 無 なら
        表示("[認証] 未認証アクセス: " + リクエスト[1])
    終わり
    返す 真    // ← 真を返すと通過、偽を返すとリクエストを拒否
終わり

ウェブ.使用(認証チェック)            // ← 全パスに適用
// ウェブ.使用("/api", 認証チェック)  // ← /api 以下にだけ適用も可能

ウェブ.GET("/", "<h1>セキュアサーバー</h1>")
ウェブ.起動()
```

**組み込みミドルウェア一覧:**

| ミドルウェア | 説明 |
|---|---|
| `"logger"` | アクセスログ出力（メソッド・パス・レスポンスタイム） |
| `"cors"` | CORS ヘッダー付与 |
| `"security"` | X-Frame-Options / CSP / HSTS 等のセキュリティヘッダー |
| `"json"` | JSON リクエストボディの自動解析 |
| `"form"` | フォームデータの自動解析 |
| `"compression"` | gzip 圧縮（Accept-Encoding 自動判定） |
| `"session"` | セッション管理の有効化 |
| `"rate_limit"` | レートリミッター（DoS 対策） |

### Step 5: セッション管理

ユーザーのログイン状態などを保持するセッション機能です。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)
ウェブ.ミドルウェア("session")       // ← セッション有効化
ウェブ.セッション有効期限(1800)      // ← 30 分で期限切れ

// ログイン
関数 ログイン(リクエスト):
    ウェブ.セッション設定("username", "太郎")
    ウェブ.セッション設定("role", "admin")
    ウェブ.JSON送信({"message": "ログインしました"})
終わり
ウェブ.GET("/login", ログイン)

// プロフィール表示
関数 プロフィール(リクエスト):
    変数 名前 = ウェブ.セッション取得("username")
    変数 権限 = ウェブ.セッション取得("role")
    ウェブ.JSON送信({"username": 名前, "role": 権限})
終わり
ウェブ.GET("/profile", プロフィール)

// ログアウト
関数 ログアウト(リクエスト):
    ウェブ.セッション破棄()
    ウェブ.JSON送信({"message": "ログアウトしました"})
終わり
ウェブ.GET("/logout", ログアウト)

ウェブ.起動()
```

```bash
$ curl -c cookies.txt http://localhost:3000/login
{"message":"ログインしました"}

$ curl -b cookies.txt http://localhost:3000/profile
{"username":"太郎","role":"admin"}
```

### Step 6: テンプレートで動的ページ

テンプレートエンジンで変数や条件分岐を使った HTML を生成できます。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(4000)

// テンプレート変数を設定
ウェブ.テンプレート変数("サイト名", "はじむショップ")
ウェブ.テンプレート変数("ログイン済み", "true")
ウェブ.テンプレート変数("ユーザー名", "太郎")

// テンプレート構文で HTML を生成
ウェブ.テンプレートGET("/", "
<html><body>
  <h1>{{サイト名}}</h1>

  {{#もし ログイン済み}}
    <p>ようこそ、{{ユーザー名}} さん！</p>
  {{/もし}}

  <p>セキュリティ: {{HTMLテスト}}</p>
</body></html>
")

ウェブ.起動()
```

**テンプレート構文:**

| 構文 | 説明 |
|---|---|
| `{{変数名}}` | 変数を HTML エスケープして展開 |
| `{{!変数名}}` | エスケープなしで展開（信頼できるデータのみ） |
| `{{#もし 条件}}...{{/もし}}` | 条件分岐 |
| `{{#書く 変数}}...{{現在}}...{{/書く}}` | カンマ区切り値のループ |
| `{{>ファイル名}}` | 外部テンプレートの読み込み |
| `{{-- コメント --}}` | コメント（出力されない） |

### Step 7: 実践的な REST API

ここまでの知識を組み合わせて、本格的な API サーバーを構築します。

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(5000)

// --- ミドルウェア ---
ウェブ.ミドルウェア("logger")
ウェブ.ミドルウェア("json")
ウェブ.ミドルウェア("security")
ウェブ.ミドルウェア("compression")
ウェブ.ミドルウェア("rate_limit")
ウェブ.レート制限設定(100, 60)       // 1 分あたり 100 リクエストまで
ウェブ.CORS設定("*", "GET,POST,PUT,DELETE", "Content-Type,Authorization")

// --- カスタムエラーハンドラ ---
関数 APIエラー(status, message, req):
    返す "{\"error\": true, \"status\": " + 文字列(status) + ", \"message\": \"" + message + "\"}"
終わり
ウェブ.エラーハンドラ(APIエラー)

// --- ヘルスチェック ---
ウェブ.JSON応答("GET", "/health", "{\"status\":\"ok\"}")

// --- API v1 ---
ウェブ.グループ("/api/v1")          // ← グループ化してプレフィックスを共通化

ウェブ.JSON応答("GET", "/items",
    "[{\"id\":1,\"名前\":\"りんご\",\"価格\":150}]")

関数 アイテム取得(リクエスト):
    変数 params = リクエスト[6]
    ウェブ.JSON送信({"id": params["id"], "名前": "りんご", "価格": 150})
終わり
ウェブ.GET("/items/:id", アイテム取得)

関数 アイテム作成(リクエスト):
    ウェブ.ステータス設定(201)
    ウェブ.JSON送信({"message": "作成しました", "id": 3})
終わり
ウェブ.POST("/items", アイテム作成)

ウェブ.グループ終了()

ウェブ.起動()
```

```bash
$ curl http://localhost:5000/api/v1/items
[{"id":1,"名前":"りんご","価格":150}]

$ curl -X POST http://localhost:5000/api/v1/items
{"message":"作成しました","id":3}

$ curl http://localhost:5000/nonexistent
{"error": true, "status": 404, "message": "Not Found"}
```

---

## 🔄 Express との対応表

Express.js を使ったことがある方のための対応表:

```
// Express.js                          // hajimu_web
const app = express()                   ウェブ.サーバー作成(3000)
app.use(cors())                         ウェブ.CORS有効()
app.use(express.json())                 ウェブ.ミドルウェア("json")

app.get('/', (req, res) => {            関数 ハンドラ(リクエスト):
  res.json({ hello: 'world' })            ウェブ.JSON送信({"hello": "world"})
})                                      終わり
                                        ウェブ.GET("/", ハンドラ)

app.get('/users/:id', ...)              ウェブ.GET("/users/:id", ...)
// req.params.id                        // リクエスト[6]["id"]
// req.query.page                       // リクエスト[7]["page"]
// req.headers['host']                  // リクエスト[5]["Host"]
// req.cookies.session                  // リクエスト[10]["session"]

res.status(201).json(data)              ウェブ.ステータス設定(201)
                                        ウェブ.JSON送信(data)

res.redirect('/login')                  ウェブ.リダイレクト("/login")
res.sendFile('doc.pdf')                 ウェブ.ファイル送信("doc.pdf")

req.session.user = 'taro'              ウェブ.セッション設定("user", "taro")
req.session.user                       ウェブ.セッション取得("user")

app.listen(3000)                        ウェブ.起動()
```

---

## ✨ 機能一覧

### コア機能

- **HTTP/1.0 & HTTP/1.1** サーバー（7 メソッド: GET / POST / PUT / DELETE / PATCH / OPTIONS / HEAD）
- **パスルーティング** — 静的パス + `:param` + `:param?`（オプショナル） + ワイルドカード `*`
- **コールバックハンドラ** — 関数をルートハンドラとして登録（Express スタイル）
- **ルートグループ** — `グループ("/api")` でプレフィックスを共通化
- **ルーターマウント** — 配列でルートを一括登録

### レスポンス

- **JSON / HTML / テキスト送信** — ヘルパー関数で簡単にレスポンス
- **テンプレートエンジン** — 変数展開・条件分岐・ループ・インクルード
- **Chunked Transfer** — ストリーミング応答（`書き込み()` → `応答終了()`）
- **gzip 圧縮** — Accept-Encoding に応じて自動圧縮
- **静的ファイル配信** — MIME 自動判別 / ETag / Cache-Control / Range リクエスト対応
- **ファイルダウンロード** — Content-Disposition 付きファイル送信

### セキュリティ

- **CORS** — オリジン / メソッド / ヘッダーの詳細設定
- **セキュリティヘッダー** — X-Frame-Options / CSP / HSTS / Permissions-Policy 自動付与
- **レートリミッター** — IP ベースのリクエスト制限（LRU テーブル管理）
- **セッション管理** — インメモリ + Cookie（暗号学的セッション ID）
- **Slowloris 防御** — 30 秒ハードタイムアウト
- **XSS / CRLF / パストラバーサル防止** — v5.3 セキュリティ監査対応済み

### パフォーマンス

- **C11 ネイティブ実装** — 高速な起動 & レスポンス
- **Keep-Alive** — 持続接続（HTTP/1.0 & 1.1 対応）
- **マルチスレッド** — スレッドプール + スレッドローカルコンテキスト（v5.4）
- **TCP_NODELAY** — Nagle アルゴリズム無効化で低レイテンシ

### その他

- **SSE（Server-Sent Events）** — リアルタイムイベント配信
- **ファイルアップロード** — multipart/form-data 解析
- **バリデーション** — required / min / max / email / number / url
- **コンテンツネゴシエーション** — Accept ヘッダーの q 値パース & 優先度判定
- **Trust Proxy** — リバースプロキシ環境での IP / プロトコル検出
- **開発者ツール** — ログ形式設定 / X-Response-Time / X-Request-Id（UUID v4）

---

## 📘 API リファレンス

### サーバー管理

| 関数 | 説明 |
|---|---|
| `サーバー作成(ポート)` | サーバーを初期化（ポート: 1〜65535） |
| `起動()` | サーバーを起動（ブロッキング） |
| `停止()` | サーバーを停止 |
| `ポート取得()` | 設定ポート番号を取得 |
| `実行中()` | サーバー実行中か判定 |
| `サーバー情報()` | バージョン・ポート・ルート数等をまとめて取得 |

### ルーティング

| 関数 | 説明 |
|---|---|
| `GET(パス, ハンドラ)` | GET ルート登録。ハンドラは文字列 or 関数 |
| `POST(パス, ハンドラ)` | POST ルート登録 |
| `PUT(パス, ハンドラ)` | PUT ルート登録 |
| `DELETE(パス, ハンドラ)` | DELETE ルート登録 |
| `PATCH(パス, ハンドラ)` | PATCH ルート登録 |
| `JSON応答(パス, ステータス, JSON)` | JSON レスポンスルート登録 |
| `ルート追加(メソッド, パス, ステータス, タイプ, 本文)` | 汎用ルート登録 |
| `グループ(プレフィックス)` | ルートグループ開始 |
| `グループ終了()` | ルートグループ終了 |
| `マウント(プレフィックス, ルート配列)` | ルーター一括マウント |
| `ルート一覧()` | 登録ルートを一覧表示 |

**パスパラメータの例:**

```
ウェブ.GET("/users/:id", ...)           // /users/42       → params["id"] = "42"
ウェブ.GET("/items/:cat/:page?", ...)   // /items/fruits   → params["page"] = null
ウェブ.GET("/files/*", ...)             // /files/a/b/c    → ワイルドカードマッチ
```

### レスポンスヘルパー

リクエストハンドラ（コールバック関数）の中で使います。

| 関数 | 説明 |
|---|---|
| `JSON送信(値)` | 辞書/配列を JSON として送信 |
| `テキスト送信(文字列)` | プレーンテキストを送信 |
| `HTML送信(HTML)` | HTML を送信 |
| `ファイル送信(パス, 名前?)` | ファイルを送信 |
| `ダウンロード(パス, 名前?)` | ダウンロード用ファイル送信 |
| `リダイレクト(URL, ステータス?)` | リダイレクト（デフォルト 302） |
| `ステータス設定(コード)` | ステータスコードを設定 |
| `コンテンツタイプ設定(タイプ)` | Content-Type を設定 |
| `ヘッダー設定(名前, 値)` | レスポンスヘッダーを設定 |
| `ヘッダー追加(名前, 値)` | ヘッダーを追記（既存値に結合） |
| `Cookie設定(名前, 値, オプション?)` | Cookie を設定 |
| `Cookie詳細設定(名前, 値, 辞書)` | 構造化オプション付き Cookie 設定 |
| `Cookie削除(名前)` | Cookie を削除 |
| `書き込み(チャンク)` | Chunked Transfer Encoding で逐次送信 |
| `応答終了(データ?)` | Chunked レスポンスを終了 |
| `ステータス送信(コード)` | コード + テキストをボディとして送信 |
| `送信済確認()` | レスポンスが送信済みか判定 |

### ミドルウェア

| 関数 | 説明 |
|---|---|
| `ミドルウェア(名前)` | 組み込みミドルウェアを有効化 |
| `使用(関数)` | 全パスにカスタムミドルウェアを適用 |
| `使用(パス, 関数)` | 特定パス以下にだけ適用 |
| `ミドルウェア一覧()` | 有効なミドルウェアを表示 |

### 設定

| 関数 | 説明 |
|---|---|
| `CORS有効()` | CORS を有効化（デフォルト設定） |
| `CORS設定(origin, methods, headers)` | CORS 詳細設定 |
| `静的ファイル(ディレクトリ)` | 静的ファイル配信ディレクトリ設定 |
| `静的ディレクトリ追加(ディレクトリ)` | 追加ディレクトリ |
| `ディレクトリ一覧(真偽値)` | ディレクトリリスティング |
| `キープアライブ(有効, タイムアウト?, 最大?)` | Keep-Alive 設定 |
| `レート制限設定(上限, 秒)` | レートリミッター設定 |
| `圧縮最小サイズ(バイト)` | gzip 発動しきい値（デフォルト 1024） |
| `アップロードディレクトリ(パス)` | アップロード保存先 |
| `アップロード最大サイズ(バイト)` | アップロード上限 |
| `信頼プロキシ(真偽値)` | Trust Proxy 有効化 |
| `最大スレッド数(数)` | スレッドプールサイズ |

### セッション

| 関数 | 説明 |
|---|---|
| `セッション取得(キー)` | セッション変数を取得 |
| `セッション設定(キー, 値)` | セッション変数を設定 |
| `セッション削除(キー)` | セッション変数を削除 |
| `セッション破棄()` | セッション全体を破棄 |
| `セッション有効期限(秒)` | タイムアウト設定（デフォルト 1800 秒） |
| `セッション再生成()` | セッション ID を再生成（セッション固定攻撃対策） |

### テンプレート

| 関数 | 説明 |
|---|---|
| `テンプレート変数(キー, 値)` | テンプレート変数を設定 |
| `テンプレートGET(パス, テンプレート)` | テンプレート付き GET ルート |
| `テンプレートディレクトリ(パス)` | テンプレートファイルのディレクトリ |
| `テンプレート描画(パス, 変数辞書)` | コールバック内でテンプレートをレンダリング |

### エラーハンドリング

| 関数 | 説明 |
|---|---|
| `エラーページ(ステータス, HTML)` | 静的エラーページ設定 |
| `JSONエラーページ(ステータス, メッセージ)` | JSON エラーレスポンス設定 |
| `エラーハンドラ(関数)` | カスタムエラーハンドラ登録（最大 8 個チェーン） |

### SSE（Server-Sent Events）

| 関数 | 説明 |
|---|---|
| `SSE(パス, コールバック?)` | SSE エンドポイント登録 |
| `SSE送信(パス, イベント, データ)` | 特定パスのクライアントに送信 |
| `SSEブロードキャスト(イベント, データ)` | 全クライアントに送信 |

### バリデーション

| 関数 | 説明 |
|---|---|
| `バリデーション(値, ルール)` | 値を検証して結果を返す |

ルール: `"required"` / `"min:数"` / `"max:数"` / `"email"` / `"number"` / `"url"`

### リクエスト情報

コールバック関数の中で使えます。

| 関数 | 説明 |
|---|---|
| `リクエスト取得(名前)` | リクエストヘッダーを取得 |
| `リクエスト種別(タイプ)` | Content-Type 判定 |
| `ホスト名取得()` | ホスト名を取得 |
| `プロトコル取得()` | "http" / "https" を取得 |
| `XHR確認()` | XMLHttpRequest 判定 |
| `サブドメイン取得()` | サブドメイン配列を取得 |
| `元URL取得()` | パス + クエリのフルパスを取得 |
| `IP一覧取得()` | X-Forwarded-For チェーン配列 |
| `フレッシュ確認()` | キャッシュの新鮮さ判定 |

### コンテンツネゴシエーション

| 関数 | 説明 |
|---|---|
| `受入確認(タイプ)` | Accept ヘッダーに含まれるか判定（q 値対応） |
| `フォーマット応答(マッピング)` | Accept に応じた分岐応答 |

### 開発者ツール

| 関数 | 説明 |
|---|---|
| `ログ形式(形式)` | `"default"` / `"combined"` / `"dev"` / `"short"` / `"tiny"` |
| `応答時間()` | X-Response-Time ヘッダー自動付与 |
| `リクエストID()` | X-Request-Id (UUID v4) 自動付与 |
| `ローカル設定(キー, 値)` | `res.locals` 相当のリクエストスコープ変数 |
| `ローカル取得(キー)` | ローカル変数を取得 |

---

## 🍳 レシピ集

### SPA + API サーバー

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)
ウェブ.CORS有効()
ウェブ.ミドルウェア("json")
ウェブ.ミドルウェア("compression")

// SPA の静的ファイル配信
ウェブ.静的ファイル("dist")

// API エンドポイント
関数 API(リクエスト):
    ウェブ.JSON送信({"data": "hello"})
終わり
ウェブ.GET("/api/data", API)

ウェブ.起動()
```

### ファイルアップロード

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)
ウェブ.ミドルウェア("form")
ウェブ.アップロードディレクトリ("uploads")
ウェブ.アップロード最大サイズ(10485760)   // 10MB

関数 アップロードフォーム(リクエスト):
    ウェブ.HTML送信("<form method='POST' enctype='multipart/form-data'>
        <input type='file' name='file'>
        <button>送信</button>
    </form>")
終わり
ウェブ.GET("/", アップロードフォーム)

関数 アップロード処理(リクエスト):
    変数 files = リクエスト[11]
    もし 長さ(files) > 0 なら
        ウェブ.アップロード保存(リクエスト, 0)
        ウェブ.JSON送信({"ok": 真, "file": files[0][1]})
    それ以外
        ウェブ.JSON送信({"ok": 偽, "error": "ファイルがありません"})
    終わり
終わり
ウェブ.POST("/", アップロード処理)

ウェブ.起動()
```

### SSE リアルタイム通知

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)

// SSE エンドポイント
ウェブ.SSE("/events")

// 通知を送信するAPI
関数 通知送信(リクエスト):
    ウェブ.SSE送信("/events", "message", "新しい通知です！")
    ウェブ.JSON送信({"sent": 真})
終わり
ウェブ.POST("/notify", 通知送信)

// クライアント HTML
ウェブ.GET("/", "<script>
    const es = new EventSource('/events');
    es.onmessage = e => document.body.innerHTML += '<p>' + e.data + '</p>';
</script><h1>リアルタイム通知</h1>")

ウェブ.起動()
```

### Chunked ストリーミング応答

```
取り込む "hajimu_web" として ウェブ

ウェブ.サーバー作成(3000)

関数 ストリーム(リクエスト):
    ウェブ.書き込み("<html><body><h1>ストリーミング</h1>")
    ウェブ.書き込み("<p>チャンク 1: データ読み込み中...</p>")
    ウェブ.書き込み("<p>チャンク 2: 処理完了</p>")
    ウェブ.応答終了("</body></html>")
終わり

ウェブ.GET("/stream", ストリーム)
ウェブ.起動()
```

---

## 🏗️ アーキテクチャ

```
はじむコード (.jp)
     │
     │  取り込む "hajimu_web" として ウェブ
     │  ウェブ.サーバー作成(8080)
     │  ウェブ.GET("/", ...)
     │  ウェブ.起動()
     │
     ▼
┌─ hajimu_web.hjp (C11 共有ライブラリ, ~5400行) ──────────┐
│                                                          │
│  ┌─────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │ HTTP パーサー │→│ ルーティング     │→│ ミドルウェア   │ │
│  │ (RFC準拠)    │  │ エンジン        │  │ チェーン      │ │
│  └─────────────┘  └─────────────────┘  └──────┬───────┘ │
│                                                │         │
│  ┌─────────────┐  ┌─────────────────┐  ┌──────▼───────┐ │
│  │ セッション   │  │ テンプレート     │  │ レスポンス    │ │
│  │ ストア      │  │ エンジン        │  │ ビルダー      │ │
│  └─────────────┘  └─────────────────┘  └──────────────┘ │
│                                                          │
│  ┌─────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │ ThreadPool  │  │ Keep-Alive      │  │ gzip圧縮     │ │
│  │ + TLS Ctx   │  │ ループ          │  │ (zlib)       │ │
│  └─────────────┘  └─────────────────┘  └──────────────┘ │
│                                                          │
└──────────────────────────────────────────────────────────┘
     │
     ▼
OS ソケット API (TCP/IP)
```

**v5.4 アーキテクチャの特徴:**
- **スレッドローカルコンテキスト** (`pthread_key_t`) — 各リクエストが独立した `RequestContext` を持ち、マルチスレッドでの競合を根本排除
- **TOCTOU 安全なセッション操作** — find→操作の間 mutex を保持
- **Slowloris 防御** — `CLOCK_MONOTONIC` ベースの 30 秒ハードタイムアウト
- **LRU 管理** — レートリミッタ・セッションストアともに容量超過時に最古エントリを自動追い出し

---

## 🔧 ビルド

### 必要環境

| 環境 | 必要なもの |
|---|---|
| コンパイラ | gcc または clang |
| ライブラリ | zlib, pthread |
| ランタイム | [はじむ言語](https://github.com/ReoShiozawa/hajimu) |
| OS | macOS / Linux / Windows (MinGW) |

### コマンド

```bash
make              # ビルド
make install      # ~/.hajimu/plugins/ にインストール
make clean        # クリーン
make uninstall    # アンインストール
make test         # テストサーバー起動
```

### 環境変数

| 変数 | デフォルト | 説明 |
|---|---|---|
| `HAJIMU_INCLUDE` | 自動検出 | はじむヘッダーのパス |
| `CC` | `gcc` | C コンパイラ |
| `NIHONGO` | 自動検出 | はじむ実行ファイルパス |

### ディレクトリ構成

```
jp-web/
├── hajimu.json            # パッケージマニフェスト
├── hajimu_web.hjp         # ビルド済みプラグイン
├── Makefile               # ビルドスクリプト
├── src/
│   └── hajimu_web.c       # プラグイン本体 (~5400行)
└── examples/
    ├── hello_server.jp    # Hello World
    ├── api_server.jp      # JSON API
    ├── callback_server.jp # コールバック + Cookie
    ├── middleware_server.jp# ミドルウェア
    ├── rest_api_server.jp # REST API (CRUD)
    ├── static_server.jp   # 静的ファイル配信
    ├── template_server.jp # テンプレートエンジン
    └── public/
        └── index.html     # 静的ファイルサンプル
```

---

## ❓ FAQ

<details>
<summary><b>Q: はじむ言語を知らなくても使えますか？</b></summary>

はい。このチュートリアルの Step 1 から始めれば、はじむの基本（変数・関数・条件分岐）も自然に覚えられます。
[はじむチュートリアル](https://reoshiozawa.github.io/hajimu-document/pages/guide.html) も参考にしてください。
</details>

<details>
<summary><b>Q: 本番環境で使えますか？</b></summary>

hajimu_web は教育・プロトタイピング・個人開発向けに設計されています。
v5.3〜v5.4 でセキュリティ監査（XSS / CRLF / パストラバーサル / Slowloris 等）を実施済みですが、大規模な本番環境では Nginx 等のリバースプロキシと組み合わせることを推奨します。
</details>

<details>
<summary><b>Q: HTTPS は使えますか？</b></summary>

`HTTPS設定(証明書, 鍵)` で TLS を有効化できます（要ビルドフラグ）。
開発中は HTTP のまま使い、本番では Nginx / Caddy のリバースプロキシで TLS を終端するのが一般的です。
</details>

<details>
<summary><b>Q: データベースとの接続は？</b></summary>

hajimu_web 自体にはデータベースドライバは含まれていません。
はじむのファイル I/O 機能と組み合わせるか、他の DB プラグインとの連携が可能です。
</details>

<details>
<summary><b>Q: ビルドで `hajimu_plugin.h が見つからない` エラーが出ます</b></summary>

はじむ言語のソースコードをビルド済みであることを確認してください:

```bash
# 方法1: HAJIMU_INCLUDE を設定
export HAJIMU_INCLUDE=/path/to/jp/include
make

# 方法2: はじむリポジトリを隣に配置
#   jp/           ← はじむ言語
#   jp-pack/jp-web/ ← このプラグイン
# → Makefile が自動検出します
```
</details>

<details>
<summary><b>Q: Windows でビルドできますか？</b></summary>

MinGW 環境でビルド可能です。MSVC は現在未サポートです:

```bash
# MSYS2/MinGW で:
pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-zlib
make CC=gcc
```
</details>

---

## 📋 変更履歴

### v5.4.0 (2026-02-12) — スレッドローカルアーキテクチャ

v5.3 セキュリティ監査で「将来的な大規模設計変更が必要」とされた残り 14 項目をすべて実装。

- **アーキテクチャ刷新:** グローバルリクエスト状態を `pthread_key_t` スレッドローカルコンテキストに全面置換
- **セッション TOCTOU 防止:** find→操作間 mutex 保持で競合ウィンドウ排除
- **HTTP/1.0 完全対応:** レスポンスバージョンマッチ + Keep-Alive 分岐
- **Slowloris 防御:** 30 秒ハードタイムアウト
- **リソース管理:** レートリミッタ LRU / セッション容量管理 / テンプレート再帰制限
- **Chunked リクエスト:** Transfer-Encoding: chunked ボディデコーダ

### v5.3.0 — セキュリティ監査対応

- XSS / CRLF / JSON インジェクション / パストラバーサル / NUL バイト防止
- `gmtime_r` / `localtime_r` / `send_all()` / 動的ヘッダーバッファ

### v5.2.0 — Express.js パリティ + 16 新 API

- HEAD リクエスト自動マッチ / 405 Allow ヘッダー / Expect: 100-continue
- req.get / req.is / res.get / res.append / Cookie 詳細設定 / セッション再生成
- ログ形式 / X-Response-Time / X-Request-Id / サーバー情報

### v5.1.0 — バグ修正 + 7 新 API

- Chunked Transfer mutex 修正 / パストラバーサル修正 / セッション mutex 追加
- IP一覧取得 / Vary設定 / リンク設定 / フレッシュ確認 等

### v5.0.0 — メジャーアップデート

- コールバック関数ハンドラ / スレッドプール / ルートグループ / SSE
- セッション / gzip 圧縮 / ファイルアップロード / バリデーション

<details>
<summary>v4.0 以前の履歴</summary>

- **v4.0:** JSON/テキスト/HTML送信 / セッション / ユーザーミドルウェア / SSE / バリデーション
- **v3.0:** コールバック関数ハンドラ / Cookie / JSON パーサー / レートリミッタ
- **v2.0:** ミドルウェア / ルートグループ / テンプレートエンジン / エラーページ
- **v1.0:** GET/POST ルーティング / 静的ファイル配信 / JSON レスポンス
</details>

---

## 🤝 コントリビューション

バグ報告・機能提案は [Issues](https://github.com/ReoShiozawa/hajimu-web/issues) へ。
プルリクエストも歓迎です。

このパッケージは、はじむの**外部パッケージ開発のリファレンス実装**としても設計されています。
独自プラグインの開発時に `hajimu.json` / `src/hajimu_web.c` / `Makefile` を参考にしてください。

## 📄 ライセンス

MIT License

## 🔗 関連リンク

- [はじむ言語](https://github.com/ReoShiozawa/hajimu) — 日本語プログラミング言語
- [はじむドキュメント](https://reoshiozawa.github.io/hajimu-document/) — 公式ドキュメント
- [チュートリアル](https://reoshiozawa.github.io/hajimu-document/pages/guide.html) — はじむ入門ガイド
- [プラグイン開発ガイド](https://reoshiozawa.github.io/hajimu-document/pages/plugins.html) — 独自プラグインの作り方
